/**
 * \file cbessel.cpp
 *
 * \brief This file contains the implementation of Bessel functions
 * of real order and complex argument.
 *
 * If CBESSEL_EXCEPT is defined, then routines will throw exceptions.
 *
 * (c) 2023 Luka MarohniÄ‡
 */

#include "cbessel.hpp"
#include <iostream>
#include <numeric>
#include <limits>
#include <cmath>

#define USE_STD_BESSEL 1
#define LIMITING_FORMS_THRESHOLD 1e-8
//#define SIN_REDUCE_TO_PI_2

#define HI(x) *(1+(int*)&x) // assuming little-endian

namespace complex_bessel {

    /* precomputed data */
    const Real D[10] = {
       -0.77822634399050712540469014052832e-11,0.11812745704870201445881285719317e-8,
       -0.61160951044814158178624971108758e-8,-0.11330272319816958823741296185618e-5,
        0.20134854780788238655689391422764e-4, 0.21524167411495097281572996305591e-3,
       -0.72189432466630995423950103404449e-2, 0.42197734555544336748208301289190e-1,
        0.42002635034095235529003934875432e-1,-0.57721566490153286060651209008240
    };
    const Real fg_coef[28] = {
        0.16666666666666666666666666666667,    0.55555555555555555555555555555555e-2,
        0.77160493827160493827160493827160e-4, 0.58454919566030677141788252899364e-6,
        0.27835675983824131972280120428268e-8, 0.90966261385046182915948105974733e-11,
        0.21658633663106234027606691898746e-13,0.83333333333333333333333333333333e-1,
        0.19841269841269841269841269841270e-2, 0.22045855379188712522045855379189e-4,
        0.14131958576403020847465291909736e-6, 0.58883160735012586864438716290567e-9,
        0.17217298460529996159192607102505e-11,0.37266879784696961383533781607154e-14,
        0.66666666666666666666666666666666e-1, 0.13888888888888888888888888888889e-2,
        0.14029180695847362514029180695847e-4, 0.83507027951472395916840361284805e-7,
        0.32747854098616625849741318150904e-9, 0.90966261385046182915948105974732e-12,
        0.18833594489657594806614514694561e-14,0.33333333333333333333333333333333,
        0.13888888888888888888888888888889e-1, 0.22045855379188712522045855379189e-3,
        0.18371546149323927101704879482657e-5, 0.94213057176020138983101946064908e-8,
        0.32712867075006992702465953494760e-10,0.81987135526333315043774319535738e-13
    };
    const Real g_coef[27] = {
        0.28218002735510577802732856336527e-2, 0.29551595693827814810411824275444e-2, 0.31007571189141127493698155423136e-2,
        0.32603029704905452472689728204689e-2, 0.34358352570203194319947068346683e-2, 0.36298018314290030475246407322153e-2,
        0.38451673228631979715111955419110e-2, 0.40855552853676180590258925703096e-2, 0.43554395320217693480267286350040e-2,
        0.46604055683625348212215275828782e-2, 0.50075137925395733265965217637280e-2, 0.54058134958992978258966706195442e-2,
        0.58670855032034623457257658591866e-2, 0.64069405257066798145061932631493e-2, 0.70464873472844527966685022425184e-2,
        0.78149449106480937308394829895925e-2, 0.87538795803476454843692547489246e-2, 0.99243701063652852104195569133095e-2,
        0.11419737767544968453057612632307e-1, 0.13389564389687457919491118658434e-1, 0.16088515817830306344627357386996e-1,
        0.19985518906371944797713031471726e-1, 0.26040916906094147125026017414173e-1, 0.36547709820363185850985355314301e-1,
        0.58496334459404825507049063909346e-1, 0.12599210498948731647672106072782,    1.2599210498948731647672106072782
    };
    const Real xi_coef[27] = {
        0.18867924528301886792452830188679e-1, 0.19607843137254901960784313725490e-1, 0.20408163265306122448979591836735e-1,
        0.21276595744680851063829787234043e-1, 0.22222222222222222222222222222222e-1, 0.23255813953488372093023255813953e-1,
        0.24390243902439024390243902439024e-1, 0.25641025641025641025641025641026e-1, 0.27027027027027027027027027027027e-1,
        0.28571428571428571428571428571428e-1, 0.30303030303030303030303030303030e-1, 0.32258064516129032258064516129032e-1,
        0.34482758620689655172413793103448e-1, 0.37037037037037037037037037037037e-1, 0.40000000000000000000000000000000e-1,
        0.43478260869565217391304347826087e-1, 0.47619047619047619047619047619047e-1, 0.52631578947368421052631578947368e-1,
        0.58823529411764705882352941176471e-1, 0.66666666666666666666666666666666e-1, 0.76923076923076923076923076923077e-1,
        0.90909090909090909090909090909091e-1, 0.11111111111111111111111111111111,    0.14285714285714285714285714285714,
        0.2,                                   0.33333333333333333333333333333333,    0.0
    };
    const Real U_C[78] = {
        1.0,                                  -0.20833333333333333333333333333333,    0.125,
        0.33420138888888888888888888888889,   -0.40104166666666666666666666666666,    0.703125e-1,
       -1.0258125964506172839506172839506,     1.8464626736111111111111111111111,    -0.8912109375,
        0.732421875e-1,                        4.6695844234262474279835390946501,    -0.11207002616222993827160493827160e2,
        8.78912353515625,                     -2.3640869140625,                       0.112152099609375,
       -0.28212072558200244877400548696844e2,  0.84636217674600734632201646090534e2, -0.91818241543240017361111111111110e2,
        0.42534998745388454861111111111110e2, -7.3687943594796316964285714285714,     0.227108001708984375,
        0.21257013003921712286096941205608e3, -0.76525246814118164229948988340191e3,  0.10599904525279998779296875e4,
       -0.69957962737613254123263888888887e3,  0.21819051174421159047929067460317e3, -0.26491430486951555524553571428571e2,
        0.5725014209747314453125,             -0.19194576623184069963100630838636e4,  0.80617221817373093845022649522270e4,
       -0.13586550006434137438550407503858e5,  0.11655393336864533247771086516203e5, -0.53056469786134031083848741319443e4,
        0.12009029132163524627685546875e4,    -0.10809091978839465550013950892857e3,  1.7277275025844573974609375,
        0.20204291330966148643451236940043e5, -0.96980598388637513488565937312207e5,  0.19254700123253153235905782021939e6,
       -0.20340017728041553427816581987713e6,  0.12220046498301745978770432648835e6, -0.41192654968897551298141479492187e5,
        0.71095143024893637214388166155132e4, -0.49391530477308801242283412388392e3,  6.0740420012734830379486083984374,
       -0.24291918790055133345853177006153e6,  0.13117636146629772006760715583323e7, -0.29980159185381067500913462030544e7,
        0.37632712976564039964021056222762e7, -0.28135632265865341107078683556188e7,  0.12683652733216247816259662310282e7,
       -0.33164517248456357783150105249313e6,  0.45218768981362726273281233651296e5, -0.24998304818112096241251988844438e4,
        0.24380529699556063860654830932616e2,  0.32844698530720378211372316410403e7, -0.19706819118432226926823389846242e8,
        0.50952602492664642206381821980497e8, -0.74105148211532657748335620964413e8,  0.66344512274729026664798798454327e8,
       -0.37567176660763351308163197964061e8,  0.13288767166421818329437411631699e8, -0.27856181280864546889594445625940e7,
        0.30818640461266239848039078427709e6, -0.13886089753717040531972253864462e5,  0.11001714026924673817120492458343e3,
       -0.49329253664509961972761831275473e8,  0.32557307418576574902022808641812e9, -0.93946235968157840254624430092036e9,
        0.15535968995705800561581210443879e10,-0.16210805521083370752481758826367e10, 0.11068428168230144682596666690962e10,
       -0.49588978427503030925463624537424e9,  0.14206290779753309518565327851791e9, -0.24474062725738728467813008156015e8,
        0.22437681779224494292307377802397e7, -0.84005433603024085288678281256681e5,  0.55133589612202058560797013342379e3
    };
    const Real lambda_coef[12] = {
        1.0,                                   0.10416666666666666666666666666667,    0.83550347222222222222222222222222e-1,
        0.12822657455632716049382716049383,    0.29184902646414046424897119341564,    0.88162726744375765241876714677641,
        3.3214082818627675447026470633764,     0.14995762986862554658672367842684e2,  0.78923013011586518138481394297045e2,
        0.47445153886826432316119486340145e3,  0.32074900908906619347043277744536e4,  0.24086549640874004869512612927478e5
    };
    const Real mu_coef[12] = {
       -1.0,                                   0.14583333333333333333333333333333,    0.98741319444444444444444444444444e-1,
        0.14331205391589506172839506172839,    0.31722720267841354809670781893004,    0.94242914795712024913730281207133,
        3.5112030408263542615427983241407,     0.15727263620368045129827117493547e2,  0.82281439097185944442246560011813e2,
        0.49235537052367052403520221673735e3,  0.33162185685479725087621015973164e4,  0.24827674245208589634728385632939e5
    };
    const Real a_coef[135] = {
       -0.16305767447865746312079440732310e-3,-0.18135869221097068720365015744785e-3,-0.20044391109497149811631779997710e-3,
       -0.22004826004542284821273001252561e-3,-0.23978401439648034204644056142302e-3,-0.25910392846703170884152708532457e-3,
       -0.27725565558293477765515932638578e-3,-0.29322647061455733150858004134460e-3,-0.30567803846632437428606654614710e-3,
       -0.31287255875806716690707735327141e-3,-0.31259471264382012432567324424727e-3,-0.30207951415545692189623948299629e-3,
       -0.27796615069490665528084461951383e-3,-0.23631487360587298676625456673139e-3,-0.17275195286917299501958874046695e-3,
       -0.82852022023213704095778729489894e-4, 0.37066305766490415156104867629216e-4, 0.18846453551445559928134299224921e-3,
        0.36805931997144315679095573742600e-3, 0.56383232975698091510844296248695e-3, 0.74936958537899064058937530949106e-3,
        0.87733523595823551072895694681526e-3, 0.87596496995118593226989815080448e-3, 0.66008814754201414296469075446947e-3,
        0.18306773598003902064368428290729e-3,-0.42997663305887191646810490788372e-3,-0.69114139728829416761374506757465e-3,
        0.53106377380288016965990945253594e-4, 0.55280437558585257692411414466105e-4, 0.57251582377759305333029628250726e-4,
        0.58919965734469849978685824584803e-4, 0.60157789453946038753089337704870e-4, 0.60802390778843649660463501857631e-4,
        0.60647852757842174231736236811172e-4, 0.59434982039310405159561161190756e-4, 0.56839620854581526598317658122447e-4,
        0.52459529495911404961643516423587e-4, 0.45800612449018875175097032083829e-4, 0.36264274585679395679094570503209e-4,
        0.23139544314828679960310229481627e-4, 0.56069048230460226731645249910139e-5,-0.17233430236696226746386149499010e-4,
       -0.46286073058811645833504325186125e-4,-0.82298287282020836506600717903698e-4,-0.12554406306069034785490836360500e-3,
       -0.17524528034084674948581332124166e-3,-0.22856408261914137420536760144879e-3,-0.27895027379132338665887799112629e-3,
       -0.31368011524757631598807939796967e-3,-0.31091625602736156801420753007171e-3,-0.23859823060300590265230469710623e-3,
       -0.63793850631886240771706039514259e-4, 0.20247195276181616738606928763729e-3, 0.37819419920177291402661228437400e-3,
       -0.10880596251059288002655623137135e-4,-0.10201141879801644092666478412559e-4,-0.93130471509356123194066867026632e-5,
       -0.81726937967865792324232957854805e-5,-0.67273929609124828701064251326590e-5,-0.49134686709848591001231157007382e-5,
       -0.26539676969793911580155569707613e-5, 0.14404004981425181705858296457703e-6, 0.35925748581935158277146073682007e-5,
        0.78262086674449666142225483781119e-5, 0.13005667479396320337364130471038e-4, 0.19321093824793925314935625392241e-4,
        0.26993971497922490105423037146330e-4, 0.36275751200534429669558338530450e-4, 0.47439429929050879906954478613466e-4,
        0.60757033496519735375509144345255e-4, 0.76449841925089825758911430916592e-4, 0.94586909303468811113319491582362e-4,
        0.11488669202982512817307087368364e-3, 0.13633917097744512017972257917339e-3, 0.15650142760859470446226638167006e-3,
        0.17022258768359256906759118358560e-3, 0.16747110669971226946798233962277e-3, 0.13019865577324269262404817295490e-3,
        0.30446550359493640984557547809681e-4,-0.15616126394515941639138744067672e-3,-0.35421197145774384077112575919506e-3,
       -0.15017941298011948227200639368501e-4,-0.16651933002139380639779740767730e-4,-0.18481621762766608450677948904027e-4,
       -0.20535275310648060449939771845813e-4,-0.22845929716472455539093305882736e-4,-0.25452272063487056593084649237650e-4,
       -0.28399679390417481098132891850017e-4,-0.31741425660902248010878044280628e-4,-0.35540053297204249773215783032345e-4,
       -0.39868872771759886358416193566252e-4,-0.44813486800888278572569826818809e-4,-0.50473104430356162801158651148118e-4,
       -0.56961156600936904805190651899499e-4,-0.64404235772101628316004065211830e-4,-0.72937434815522121128042909531065e-4,
       -0.82692304558819327395907636905815e-4,-0.93769954989119449192203265284783e-4,-0.10618431920797401996427365800136e-3,
       -0.11974497568425405128661594303757e-3,-0.13381550386749136668731254680770e-3,-0.14680975664646554927600206825790e-3,
       -0.15512192491809622298489674331520e-3,-0.15080355805304876165913644261662e-3,-0.11644493167204863969339740154889e-3,
       -0.14198627355669119743170416071155e-4, 0.23224174518292165350988880400645e-3, 0.69373554135458897363659268421173e-3,
        0.76698134535920738822981735920026e-4, 0.80349754840779115118527792686343e-4, 0.84296310571570022307310425969687e-4,
        0.88571085247871171841465714321604e-4, 0.93212051724950325556340576094768e-4, 0.98262607836936344827055283763022e-4,
        0.10377241042299282299872357661726e-3, 0.10979829837271336857688565720615e-3, 0.11640527147473790200435574891628e-3,
        0.12366744559825326113590685697667e-3, 0.13166881654592280577658878987589e-3, 0.14050349739126979402492618250250e-3,
        0.15027477416090813375156189912292e-3, 0.16109170592901575165122291528870e-3, 0.17306077591787649317198781772621e-3,
        0.18626763663754517240298521442132e-3, 0.20073885876275235483926619901228e-3, 0.21636248571236508187456112118019e-3,
        0.23272104008323209792086856602634e-3, 0.24873043734465560936669729402824e-3, 0.26182429706150094464910024307627e-3,
        0.26599558934625477989234975282983e-3, 0.24669137274179290986013675089305e-3, 0.16592768783244973721164197354674e-3,
       -0.88489288489288489288489288489289e-4,-0.92207792207792207792207792207792e-3,-0.44444444444444444444444444444444e-2
    };
    const Real b_coef[162] = {
       -0.29164736331209081312564210294074e-3,-0.29655733423934810879622374237259e-3,-0.29743596217631660869367680903513e-3,
       -0.29308156319286116237511946609955e-3,-0.28205046986759867560740874825563e-3,-0.26262881146466885273433555202760e-3,
       -0.23281145037693741085149902105840e-3,-0.19029618798961406510617601585087e-3,-0.13250618677298261547638731412910e-3,
       -0.56660746163525207952422550452146e-4, 0.40074955527061428982835687182009e-4, 0.16031569459472150302855817950408e-3,
        0.30599192635878950067137210273048e-3, 0.47760387285658225730723702803648e-3, 0.67307320816566561871092726136189e-3,
        0.88604744041979162741073657371436e-3, 0.11035159737564269365727794817032e-2, 0.13026826128565718105351973603480e-2,
        0.14473233983061758988938179940682e-2, 0.14845749525944917918749472005490e-2, 0.13446744970154036199777513747912e-2,
        0.94926611717688106192685270229217e-3, 0.23907947525692728428863607470604e-3,-0.76220459635400983194962682139792e-3,
       -0.18342266354985679819552836890436e-2,-0.24340296293804253831049911736060e-2,-0.18018219196388569702524280320237e-2,
        0.24892338100459515560526581872202e-4, 0.20822362948246684657072244654427e-4, 0.15647778542887261955332128608593e-4,
        0.91642647412277884783442663217152e-5, 0.11369868667510028924115784585557e-5,-0.87010609684976705736826150188841e-5,
       -0.20648976103555175688209716834308e-4,-0.35034775051190052035399067932306e-4,-0.52207002889563380288638039297622e-4,
       -0.72517832771442533423559617854044e-4,-0.96292614771764418897765393843711e-4,-0.12377824076187362998730055939550e-3,
       -0.15505891859909386975702662600112e-3,-0.18992261185456235570251960860327e-3,-0.22765421412281952702942643463012e-3,
       -0.26672272304761282054104716516121e-3,-0.30432112478903980872943496466563e-3,-0.33571563577504875679729258374587e-3,
       -0.35338247091603771209147500853652e-3,-0.34599812683265634750756435450956e-3,-0.29760364659455453485814225074593e-3,
       -0.18790600363697155771061250410365e-3, 0.38473767287936609521649115189250e-5, 0.28599815419430414707463189182072e-3,
        0.62261486257313506617210360556181e-3, 0.87279080514619397591397616938255e-3, 0.73646581057257844419684316936484e-3,
        0.14554742826152400369612683952719e-4, 0.17009198463641262268177573311834e-4, 0.19789305666402163624023792707490e-4,
        0.22936363369099815190267234085966e-4, 0.26495611995051603864523941960132e-4, 0.30515799503434665897155579761281e-4,
        0.35048173003132808110125259917052e-4, 0.40144551389148680793708202648792e-4, 0.45853948516536064567575256645502e-4,
        0.52216930882697556726831460453086e-4, 0.59256454732319470361975109244770e-4, 0.66963252197573087228394143200235e-4,
        0.75272799134913406213966701410822e-4, 0.84029313301608997792791428560670e-4, 0.92929839659336389557003160201353e-4,
        0.10143795159766197259744643803268e-3, 0.10865163484877426783725834040100e-3, 0.11310364210848138896645320450327e-3,
        0.11246677526220415776689563795901e-3, 0.10313823670827219976057867990913e-3, 0.79709268407567492367714140908216e-4,
        0.34457129429496750303162142309969e-4,-0.42577810128543520436520347161882e-4,-0.16110501611996228189965892548228e-3,
       -0.32039022806703760345411634902401e-3,-0.47786456714732148726088405941268e-3,-0.47461779655995980754441833052401e-3,
       -0.19820063888529492723804307743487e-4,-0.21147965676891297111202789169595e-4,-0.22582350951834603251449233409648e-4,
       -0.24130835676128020048061636712543e-4,-0.25800617466688371345624466839686e-4,-0.27597891482833575859843395280853e-4,
       -0.29526956175080731515819620104259e-4,-0.31588856077210962111736489489196e-4,-0.33779330612336741747859414100601e-4,
       -0.36085716753541050065863558493230e-4,-0.38482263860322127360238695087209e-4,-0.40923019315775036382717157737122e-4,
       -0.43330964451126603594760934484892e-4,-0.45581305813862845170501667494642e-4,-0.47475562089008663848135925928288e-4,
       -0.48701003118673506908553802132192e-4,-0.48766544741378735197688695324695e-4,-0.46900488937914102934457810642110e-4,
       -0.41886186169669336451328627892555e-4,-0.31797241335042713537516852511660e-4,-0.13574499634326913612610395663071e-4,
        0.17625868306999139680704259467086e-4, 0.69327110565704359773882466147305e-4, 0.15246815619844660150881198146978e-3,
        0.27952065399202058881025943337723e-3, 0.44793258155238464640564614485062e-3, 0.55221307672129279005986982501080e-3,
        0.19591345014117924393561322125875e-4, 0.20116524199708166564270229271571e-4, 0.20638874978217073674111266439938e-4,
        0.21150764925622084338363602077484e-4, 0.21641842744810390520666189825875e-4, 0.22098101536199142935315249568751e-4,
        0.22500588110529241837816367896144e-4, 0.22823607372034872158766487495375e-4, 0.23032197608090914387998647501280e-4,
        0.23078538981117781675851116621588e-4, 0.22896778381471262867210587803497e-4, 0.22395465923245651411764282492509e-4,
        0.21446326379082263871554093590305e-4, 0.19867297884213378041594479893443e-4, 0.17396412547292626068259847326273e-4,
        0.13650700926214739094591893951242e-4, 0.80599616541427357065762654936331e-5,-0.24289260857573038860698388336231e-6,
       -0.12608973598023004671772761542060e-4,-0.31203892907609834030874055838930e-4,-0.59614195304645789476286284303015e-4,
       -0.10400855046081643397831523069418e-3,-0.17546399697078282820531686814719e-3,-0.29482213851274602513185100549750e-3,
       -0.50291654957203461354020960645354e-3,-0.87820470954638932839154179063920e-3,-0.14928295321342917205007340333366e-2,
        0.70990630063415348115870558051045e-4, 0.75900226964621933905416032514839e-4, 0.81346626216280146664971179182542e-4,
        0.87413054575383443683303226618903e-4, 0.94199822420423750872419384517656e-4, 0.10182877074056725765729253072988e-3,
        0.11044914450459939247401564721758e-3, 0.12024544494930288371565371288594e-3, 0.13144806811996537900758522870666e-3,
        0.14434793019733398621012664758494e-3, 0.15931689966182108118588356273978e-3, 0.17683685501971800374456069461436e-3,
        0.19754183803306252402068932315418e-3, 0.22228058079888332665663421006211e-3, 0.25221161554957328357875228204320e-3,
        0.28895214849575151669235935385144e-3, 0.33481888931829766411195842563706e-3, 0.39323283546291663799066153634529e-3,
        0.46943100760648153296533950525080e-3, 0.57178728178970487168319645188412e-3, 0.71443042172728735736186199506993e-3,
        0.92287887657293831079181693201455e-3, 0.12475311058919920157895009989263e-2, 0.18009660676105394060665593609959e-2,
        0.28850140223113277910192074676657e-2, 0.55996491106438807322987138101255e-2, 0.17998872141355330925245865818261e-1
    };

    /* some constants */
    const Real eps      =   numeric_limits<Real>::epsilon();
    const Real NaN      =   numeric_limits<Real>::quiet_NaN();
#ifndef CBESSEL_EXCEPT
    const Real infty    =   numeric_limits<Real>::infinity();
#endif
    const Real airy_C1  =   0.35502805388781723926006318600418;
    const Real airy_C2  =   0.25881940379280679840518356018921;
    const Real f13      =   1/3.0;
    const Real f23      =   2/3.0;
    const Real f32      =   3/2.0;
    const Real f43      =   4/3.0;
    const Real f16      =   1/6.0;
    const Real sqrt_1_3 =   sqrt(f13);

    /* exceptions */
#ifdef CBESSEL_EXCEPT
    const overflow_error of_err("Overflow");
    const underflow_error uf_err("Underflow");
    const invalid_argument ia_err("Undefined");
    const length_error cvg_err("Failed to converge");
#endif

    /* utilities */
    Real sign1(Real x) {
        return x>=0.0?1.0:-1.0;
    }
    bool undef(const Cplx &z) {
        return isnan(z.real()) || isnan(z.imag());
    }
    bool zero(Real x) {
        int c=fpclassify(x);
        return c==FP_ZERO || c==FP_SUBNORMAL;
    }
    bool inf(const Cplx &z) {
        return isinf(real(z)) || isinf(imag(z));
    }
    bool zero(const Cplx &z) {
        return zero(real(z)) && zero(imag(z));
    }
    Real v_L(Real eps) {
        return -8.0-6.0*log10(eps);
    }

    /* Olver expansion routines for large order */
    olver_data::olver_data() {
        is_valid=false;
        S1=S2=0.0;
    }
    Cplx U(int k,const Cplx &t2) {
        size_t k0=(k*(k+1))/2;
        return accumulate(U_C+k0,U_C+k0+k+1,Cplx(0,0),[&t2](Cplx &a,Real c) { return a*t2+c; });
    }
    void olver(Real v,const Cplx &z,Real s,OlverData &data) {
        Cplx zv=-s*z*1i/v,w2=1.0-zv*zv,w=sqrt(w2);
        Real iv2=1.0/(v*v),v13=pow(v,-f13);
        int j,k;
        if (abs(w2)>0.25) {
            data.xi=log((1.0+w)/zv)-w;
            data.phi=pow(12.0*data.xi,f16)/sqrt(w)*v13;
            Cplx t=1.0/w,t2=1.0/w2,tk,ix=f23/data.xi,A,B;
            for (k=6;k-->0;) {
                A=0.0,B=0.0,tk=w;
                for (j=2*(k+1);j-->0;) {
                    if (j<=2*k)
                        A=A*ix-mu_coef[j]*U(2*k-j,t2)*tk;
                    B=B*ix-lambda_coef[j]*U(2*k-j+1,t2)*(tk*=t);
                }
                data.S1=data.S1*iv2+A;
                data.S2=data.S2*iv2+B;
            }
            data.S2*=pow(ix,f13);
            Real u=sign1(imag(data.xi));
            if (s*u<0.0) {
                data.S2*=exp(u*M_PI*f23*1i);
                data.phi*=exp(-u*M_PI*f13*1i);
            }
        } else {
            Cplx a0(0.0);
            data.xi=w*accumulate(xi_coef,xi_coef+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            data.phi=v13*accumulate(g_coef,g_coef+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            const Real *ac=a_coef,*bc=b_coef;
            for (k=0;k<6;++k,ac+=27,bc+=27) {
                data.S1=data.S1*iv2+(k==5?1.0:accumulate(ac,ac+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; }));
                data.S2=data.S2*iv2+accumulate(bc,bc+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            }
        }
        data.is_valid=true;
    }
    int airy_olver(Real v,const Cplx &xi,Real s,Cplx &ai,Cplx &aip,bool &corr,bool rot,bool scaled);

    /* workhorse routines */
    Cplx K_in(Real v,const Cplx &z,bool scaled,Cplx *K_val_1=nullptr,OlverData *data=nullptr);
    Cplx K0_in(const Cplx &z,bool scaled);
    Cplx K1_in(const Cplx &z,bool scaled);
    Cplx I_in(Real v,const Cplx &z,bool scaled,Cplx *K_val=nullptr,OlverData *data=nullptr) {
        if (undef(z) || (inf(z) && isinf(v)))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NaN;
#endif
        if (isinf(v))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return zero(v)?1.0:0.0;
        if (v<0.0 && v==round(v))
            return I_in(-v,z,scaled);
        if (real(z)<0.0)
            return exp(v*M_PI*sign1(imag(z))*1i)*I_in(v,-z,scaled);
        if (v<0.0) {
            OlverData data;
            Cplx Kv=NaN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(-v,z,scaled,&Kv,&data);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(-v,z,false,nullptr,&data)*(scaled?exp(-real(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            return Iv-M_2_PI*sin(M_PI*v)*Kv;
        }
#ifdef USE_STD_BESSEL
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(v,imag(z))*exp(1i*v*M_PI_2);
#endif
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z),vL=v_L(eps);
        int maxiter=CBESSEL_MAXITER,j;
        if (R<=2.0*sqrt(v+1.0)) {
            Real tg=tgamma(1.0+v),scale=scaled?exp(-real(z)):1.0;
            Cplx A=1.0,z24=0.25*z*z,a=isinf(tg)?NaN:scale*pow(z2,-v)/tg,res=1.0;
            if (zero(a))
#ifdef CBESSEL_EXCEPT
                throw uf_err;
#else
                return 0.0;
#endif
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*(k+v)));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            if (undef(a)) {
                Real vfl=floor(v),vf=v-vfl;
                int vi=int(vfl);
                res*=scale*pow(z2,vf)/(vf*tgamma(vf));
                for (j=1;j<=vi;++j) res*=z2/(vf+j);
#ifdef CBESSEL_EXCEPT
                if (zero(res)) throw uf_err;
#endif
                return res;
            }
            return res*a;
        }
        if (v>vL) {
            Real theta=arg(z),s=sign1(theta);
            if (3.0*abs(theta)<M_PI) {
                Real iv=1.0/v;
                Cplx zv=z*iv,zv2=zv*zv,it2=1.0+zv2,it=sqrt(it2),zet=it-log((1.0+it)/zv);
                Cplx t=1.0/it,t2=1.0/it2,tk=pow(t2,6),res=0.0;
                for (int k=12;k-->1;)
                    res=res*iv+U(k,t2)*(tk*=it);
                Cplx ret=sqrt(t*M_1_PI*iv*0.5)*exp((scaled?-real(z):0.0)+v*zet)*(iv*res+1.0);
#ifdef CBESSEL_EXCEPT
                if (inf(ret)) throw of_err;
                if (zero(ret)) throw uf_err;
#endif
                return ret;
            }
            Cplx ai,aip,C,ret;
            OlverData od;
            if (data==nullptr) data=&od;
            olver(v,z,s,*data);
            bool corr;
            int e=airy_olver(v,data->xi,s,ai,aip,corr,false,scaled);
            C=exp(s*M_PI*v*1i*0.5-(scaled?real(z)+(corr?v*data->xi:0.0):0.0))*data->phi;
#ifdef CBESSEL_EXCEPT
            if (e==1) { if (zero(C)) throw ia_err; throw of_err; }
            if (e==2) { if (inf(C)) throw ia_err; throw uf_err; }
            if (inf(C)) throw of_err;
            if (zero(C)) throw uf_err;
#endif
            ret=C*(ai*data->S1+aip*pow(v,-f43)*data->S2);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
            if (zero(ret)) throw uf_err;
#endif
            return ret;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4,v2=v*v;
        if (R>RL && 2.0*R>v2) {
            Cplx f2=exp(sign1(imag(z))*(v+.5)*M_PI*1i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?1i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=4.0*v2-1.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        if (R>vL && 2.0*R<=v2) {
            v2=v,j=0;
            while (v2<=vL) ++j,++v2;
            Cplx i1=I_in(v2,z,scaled);
            if (inf(i1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx i0=I_in(v2+1.0,z,scaled);
            for (;j-->0;v2--) {
                i0+=v2*z2*i1,swap(i0,i1);
#ifdef CBESSEL_EXCEPT
                if (inf(i1)) throw of_err;
#endif
            }
            return i1;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),vi=(int)floor(v),nu=max(Ri,vi),k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps,vf=v-floor(v);
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (abs(p1)<=(k+1)*(k+1)*bnd && k++<maxiter)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=R>v?k:max(M+vi,k+Ri);
        }
        Cplx y0=0.0,y1=eps,yt;
        vector<Cplx> y;
        vector<Cplx>::iterator ybeg,it,jt;
        int jmax=int(M+(R>v?Ri-vi:0));
        if (with_y) {
            jmax+=vi;
            y.resize(jmax+1);
            ybeg=it=y.begin();
            *it=y1;
        }
        Real vfnuM=vf+nu+M,vf2=2.0*vf,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) for (jt=ybeg;jt<=it;++jt) *jt*=scl;
                continue;
            }
            y0=yt; ++j;
            if (with_y) *(++it)=y0;
            swap(y0,y1);
        }
        if (with_y) {
            Real lambda=2.0; j=1;
            Cplx ip=accumulate(next(y.crbegin()),y.crend(),*it,[&](const Cplx &a,const Cplx &yk) {
                Cplx res=a+yk*lambda*(1.0+vf/j);
                lambda*=1.0+vf2/j++;
                return res;
            });
            return y[jmax-vi]*(scaled?exp(1i*imag(z)):exp(z))*pow(z2,-vf)/(ip*tgamma(1.0+vf));
        }
        Cplx Kv_1=NaN,k1,k2,r=y0/y1,scale=scaled?exp(1i*imag(z)):1.0;
        k1=K_in(v,z,scaled,&Kv_1);
        if (K_val!=nullptr) *K_val=k1;
        if (undef(Kv_1)) {
            k2=K_in(v+1.0,z,scaled);
            return scale/(z*(k2+r*k1));
        }
        return scale/(2.0*v*k1+z*(Kv_1+r*k1));
    }
    Cplx I0_in(const Cplx &z,bool scaled,Cplx *K_val=nullptr) {
        if (undef(z))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NaN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return 1.0;
        if (real(z)<0.0)
            return I0_in(-z,scaled);
#ifdef USE_STD_BESSEL
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(0.,imag(z));
#endif
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z);
        int maxiter=CBESSEL_MAXITER,j;
        if (R<=2.0) {
            Cplx A=1.0,z24=0.25*z*z,res=1.0;
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*k));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return scaled?res*exp(-real(z)):res;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4;
        if (R>RL) {
            Cplx f2=exp(sign1(imag(z))*.5*M_PI*1i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?1i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=-1.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),nu=Ri,k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps;
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (abs(p1)<=(k+1)*(k+1)*bnd && k++<maxiter)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=k;
        }
        Cplx y0=0.0,y1=eps,yt,sum=0.0;
        int jmax=int(M+Ri);
        Real vfnuM=nu+M,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) sum*=scl;
                continue;
            }
            y0=yt; ++j;
            if (j==jmax) sum*=2.0;
            if (with_y) sum+=y0;
            swap(y0,y1);
        }
        if (with_y)
            return y1*(scaled?exp(1i*imag(z)):exp(z))/sum;
        Cplx k1,k2,r=y0/y1,scale=scaled?exp(1i*imag(z)):1.0;
        k1=K0_in(z,scaled);
        k2=K1_in(z,scaled);
        if (K_val!=nullptr) *K_val=k1;
        return scale/(z*(k2+r*k1));
    }
    Cplx I1_in(const Cplx &z,bool scaled,Cplx *K_val=nullptr) {
        if (undef(z))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NaN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return 0.0;
        if (real(z)<0.0)
            return -I1_in(-z,scaled);
#ifdef USE_STD_BESSEL
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(1.0,imag(z))*1i;
#endif
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z);
        int maxiter=CBESSEL_MAXITER,j;
        if (R<=2.0*M_SQRT2) {
            Cplx A=1.0,z24=0.25*z*z,res=1.0;
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*(k+1)));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return res*(scaled?exp(-real(z)):1.0)*z*0.5;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4;
        if (R>RL) {
            Cplx f2=exp(sign1(imag(z))*1.5*M_PI*1i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?1i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=3.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),nu=max(Ri,1),k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps;
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (k++<maxiter && abs(p1)<=k*k*bnd)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=R>1.0?k:max(M+1,k+Ri);
        }
        Cplx y0=0.0,y1=eps,yt,sum=0.0;
        int jmax=int(M+(R>1.0?Ri-1:0))+(with_y?1:0);
        Real vfnuM=nu+M,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) sum*=scl;
                continue;
            }
            y0=yt; ++j;
            if (with_y) {
                if (j==jmax) sum*=2.0;
                sum+=y0;
            }
            swap(y0,y1);
        }
        if (with_y)
            return y0*(scaled?exp(1i*imag(z)):exp(z))/sum;
        Cplx k1,k2,r=y0/y1,scale=scaled?exp(1i*imag(z)):1.0;
        k1=K1_in(z,scaled);
        k2=K_in(2.0,z,scaled);
        if (K_val!=nullptr) *K_val=k1;
        return scale/(z*(k2+r*k1));
    }
    Cplx K_in(Real v,const Cplx &z,bool scaled,Cplx *K_val_1,OlverData *data) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z) && isinf(v))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NaN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (isinf(v))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (v<0.0)
            return K_in(-v,z,scaled);
        if (real(z)<0.0) {
            Cplx Kv=NaN,Iv,si=sign1(imag(z))*M_PI*1i;
            OlverData data;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(v,-z,scaled,&Kv,&data)*(scaled?exp(1i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(v,-z,false,nullptr,&data)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=exp(-si*v)*Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        if (v>v_L(eps)) {
            Real theta=arg(z),s=sign1(theta);
            if (3.0*abs(theta)<M_PI) {
                Real iv=1.0/v;
                Cplx zv=z*iv,zv2=zv*zv,it2=1.0+zv2,it=sqrt(it2),zet=it-log((1.0+it)/zv);
                Cplx t=1.0/it,t2=1.0/it2,tk=pow(t2,6),res=0.0;
                for (int k=12;k-->1;)
                    res=res*iv+(k%2?-1.0:1.0)*U(k,t2)*(tk*=it);
                Cplx ret=sqrt(M_PI_2*t*iv)*exp((scaled?z:0.0)-v*zet)*(iv*res+1.0);
#ifdef CBESSEL_EXCEPT
                if (inf(ret)) throw of_err;
                if (zero(ret)) throw uf_err;
#endif
                return ret;
            }
            Cplx si=M_PI*s*1i,ai,aip,C,ret;
            OlverData od;
            if (data==nullptr) data=&od;
            if (!data->is_valid)
                olver(v,z,s,*data);
            bool corr;
            int e=airy_olver(v,data->xi,s,ai,aip,corr,true,scaled);
            C=-si*exp(si*(f13-v*0.5)+(scaled?z+(corr?v*data->xi:0.0):0.0))*data->phi;
#ifdef CBESSEL_EXCEPT
            if (e==1) { if (zero(C)) throw ia_err; throw of_err; }
            if (e==2) { if (inf(C)) throw ia_err; throw uf_err; }
            if (inf(C)) throw of_err;
            if (zero(C)) throw uf_err;
#endif
            ret=C*(ai*data->S1+exp(-si*f23)*aip*pow(v,-f43)*data->S2);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
            if (zero(ret)) throw uf_err;
#endif
            return ret;
        }
        Cplx k0,k1,z2=2.0/z;
        int jmax=0;
        while (v>0.5) jmax++,v--;
        Real R=abs(z),theta=arg(z);
        if (v==0.5) {
            k0=sqrt(M_PI_4*z2)*(scaled?1.0:exp(-z));
            k1=(z2*0.5+1.0)*k0;
        } else if (R<=2.0) {
            bool vz=zero(v);
            Real s=vz?1.0:M_PI*v/sin(M_PI*v),g2=1.0/tgamma(1.0+v),g1=1.0/(s*g2),gama1,gama2=(g1+g2)*0.5;
            if (vz)
                gama1=D[9];
            else if (abs(v)>0.1)
                gama1=(g1-g2)*0.5/v;
            else {
                Real v2=v*v;
                gama1=accumulate(D,D+10,0.0,[&v2](Real &a,Real d) { return a*v2+d; });
            }
            Cplx lz2=log(z2),mu=v*lz2,z2v=pow(z2,-v),z2d4=1.0/(z2*z2),scale=scaled?exp(z):1.0;
            Cplx p=0.5*scale/(g2*z2v),q=0.5*scale*z2v/g1,C=1.0;
            Cplx f=s*scale*(gama1*cosh(mu)+gama2*lz2*(vz?1.0:sinh(mu)/mu));
            Real A=0.5,a=0.25*R*R,k=1.0,kmv,kpv,ki,maxiter=CBESSEL_MAXITER;
            k0=f,k1=p;
            do {
                ki=1.0/k,kmv=1.0/(k-v),kpv=1.0/(k+v);
                C*=z2d4*ki,A*=a*ki*kmv;
                f=(k*f+p+q)*kmv*kpv;
                p*=kmv,q*=kpv;
                k0+=C*f,k1+=C*(p-k*f);
                if (inf(k0) || inf(k1))
#ifdef CBESSEL_EXCEPT
                    throw of_err;
#else
                    return infty;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            k1*=z2;
            if (inf(k1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
        } else {
            Real v2=v*v,A=3.0/(1.0+R),B=14.7/(28.0+R);
            Real C=2.0*M_2_SQRTPI*(abs(abs(v)-.5)<eps?M_PI*eps:cos(M_PI*v))/(eps*pow(2.0*R,0.25));
            Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
            k0=0.0,k1=eps;
            Cplx S=0.0;
            for (Real n=M;n-->1.0;swap(k0,k1)) {
                S+=k1;
                k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5)-v2);
            }
            Cplx r=z+v+.5-k0/k1;
            k0=(scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
            k1=0.5*k0*r*z2;
        }
        if (jmax==0)
            return k0;
        for (int j=1;j<jmax;++j,swap(k0,k1))
            if (inf(k0+=(++v)*z2*k1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
        if (K_val_1!=nullptr) *K_val_1=k0;
#ifdef CBESSEL_EXCEPT
        if (zero(k1)) throw uf_err;
#endif
        return k1;
    }
    Cplx K0_in(const Cplx &z,bool scaled) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (real(z)<0.0) {
            Cplx Kv=NaN,Iv,si=sign1(imag(z))*M_PI*1i;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I0_in(-z,scaled,&Kv)*(scaled?exp(1i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K0_in(-z,false)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx k0,k1,z2=2.0/z;
        Real R=abs(z),theta=arg(z);
        if (R<=2.0) {
            Cplx lz2=log(z2),z2d4=z*z*0.25,scale=scaled?exp(z):1.0,p=scale,C=1.0,f=scale*(D[9]+lz2);
            Real A=0.5,a=0.25*R*R,k=1.0,ki,maxiter=CBESSEL_MAXITER;
            k0=f;
            do {
                ki=1.0/k;
                C*=z2d4*ki,A*=a*ki*ki;
                f=(f+(p*=ki))*ki;
                k0+=C*f;
#ifdef CBESSEL_EXCEPT
                if (inf(k0)) throw of_err;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return k0;
        }
        Real A=3.0/(1.0+R),B=14.7/(28.0+R),C=2.0*M_2_SQRTPI/(eps*pow(2.0*R,0.25));
        Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
        k0=0.0,k1=eps;
        Cplx S=0.0;
        for (Real n=M;n-->1.0;swap(k0,k1)) {
            S+=k1;
            k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5));
        }
        return (scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
    }
    Cplx K1_in(const Cplx &z,bool scaled) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (real(z)<0.0) {
            Cplx Kv=NaN,Iv,si=sign1(imag(z))*M_PI*1i;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I1_in(-z,scaled,&Kv)*(scaled?exp(1i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K1_in(-z,false)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=-Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx k0,k1,z2=2.0/z;
        Real R=abs(z),theta=arg(z);
        if (R<=2.0) {
            Cplx lz2=log(z2),z2d4=z*z*0.25,scale=scaled?exp(z):1.0,p=0.5*scale,C=1.0,f=scale*(D[9]+lz2);
            Real A=0.5,a=0.25*R*R,k=1.0,ki,maxiter=CBESSEL_MAXITER;
            k1=p;
            do {
                ki=1.0/k;
                C*=z2d4*ki,A*=a*ki*ki;
                f=(f+2.0*(p*=ki))*ki;
                k1+=C*(p-k*f);
#ifdef CBESSEL_EXCEPT
                if (inf(k1)) throw of_err;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
#ifdef CBESSEL_EXCEPT
            if (inf(k1)) throw of_err;
#endif
            return k1*z2;
        }
        Real A=3.0/(1.0+R),B=14.7/(28.0+R),C=2.0*M_2_SQRTPI/(eps*pow(2.0*R,0.25));
        Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
        k0=0.0,k1=eps;
        Cplx S=0.0;
        for (Real n=M;n-->1.0;swap(k0,k1)) {
            S+=k1;
            k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5));
        }
        Cplx r=z+.5-k0/k1;
        k0=(scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
        k1=0.5*k0*r*z2;
        return k1;
    }

    /* Bessel functions J_v(z) and Y_v(z) */
    Cplx BesselJ(Real v,const Cplx &z,bool scaled) {
        Cplx si=sign1(imag(z))*1i;
#ifdef USE_STD_BESSEL
        if (!scaled && zero(z.imag()) && z.real()>0) {
            if (zero(round(v)-v))
                return jn((int)round(v),z.real());
            return cyl_bessel_j(v,z.real());
        }
#endif
        if (v>=0.0) {
#if USE_STD_BESSEL
            if (!scaled && zero(abs(arg(z)-M_PI)))
                return exp(si*M_PI*v)*cyl_bessel_j(v,-real(z));
#endif
            if (v==0.0)
                return I0_in(-z*si,scaled);
            if (v==1.0)
                return si*I1_in(-z*si,scaled);
        }
        return exp(si*M_PI_2*v)*I_in(v,-z*si,scaled);
    }
    Cplx BesselY(Real v,const Cplx &z,bool scaled) {
#ifdef USE_STD_BESSEL
        if (!scaled && zero(imag(z)) && z.real()>0 && v>=0.0) {
            if (zero(round(v)-v))
                return yn((int)round(v),z.real());
            return cyl_neumann(v,z.real());
        }
#endif
        Real s=sign1(imag(z)),va=abs(v);
        Cplx si=1i*s,a=exp(va*M_PI_2*si),iz=z*si,Kv=NaN,Iv;
#ifdef CBESSEL_EXCEPT
        try {
#endif
            if (va==0.0)
                Iv=I0_in(-iz,scaled,&Kv);
            else if (va==1.0)
                Iv=I1_in(-iz,scaled,&Kv);
            else Iv=I_in(va,-iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try
#endif
            {
            if (va==0.0)
                Kv=K0_in(-iz,false);
            else if (va==1.0)
                Kv=K1_in(-iz,false);
            else Kv=K_in(va,-iz,false);
            if (scaled)
                Kv*=exp(-abs(imag(z)));
            }
#ifdef CBESSEL_EXCEPT
        catch (const underflow_error &e) { Kv=0.0; }
#endif
        Cplx ret=si*a*Iv-M_2_PI*Kv/a;
        if (v>=0.0)
            return ret;
        int n;
        if (abs(2.0*v-(n=int(round(2.0*v))))<eps && n%2)
            return ((-n/2)%2?-1.0:1.0)*a*Iv;
        if (va==0.0)
            return ret;
        if (va==1.0)
            return -ret;
        return cos(M_PI*va)*ret+sin(M_PI*va)*a*Iv;
    }
    /* modified Bessel functions I_v(z) and K_v(z) */
    Cplx BesselI(Real v,const Cplx &z,bool scaled) {
#ifdef USE_STD_BESSEL
        if (!scaled && zero(z.imag()) && z.real()>=0)
            return cyl_bessel_i(v,z.real());
#endif
        if (v==0.0)
            return I0_in(z,scaled);
        if (v==1.0)
            return I1_in(z,scaled);
        return I_in(v,z,scaled);
    }
    Cplx BesselK(Real v,const Cplx &z,bool scaled) {
#if USE_STD_BESSEL
        if (!scaled && zero(z.imag()) && z.real()>=0)
            return cyl_bessel_k(v,z.real());
#endif
        if (v==0.0)
            return K0_in(z,scaled);
        if (v==1.0)
            return K1_in(z,scaled);
        return K_in(v,z,scaled);
    }
    /* Hankel function H^(kind)_v(z) */
    inline Cplx H(Real v,const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real va=abs(v),s=kind==1?1.0:-1.0;
        Cplx si=1i*s,a=exp(M_PI_2*va*si),iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=1i*M_1_PI/a*K_in(va,-iz,scaled);
        } else {
            OlverData data;
            Cplx Kv=NaN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(va,iz,scaled,&Kv,&data);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(va,iz,false,nullptr,&data)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=1i*M_1_PI*a*Kv-s*Iv/a*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*(v>=0.0?ret:a*a*ret);
    }
    inline Cplx H_v0(const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real s=kind==1?1.0:-1.0;
        Cplx si=1i*s,iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=1i*M_1_PI*K0_in(-iz,scaled);
        } else {
            Cplx Kv=NaN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I0_in(iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K0_in(iz,false)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=1i*M_1_PI*Kv-s*Iv*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*ret;
    }
    inline Cplx H_v1(const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real s=kind==1?1.0:-1.0;
        Cplx si=1i*s,iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=s*M_1_PI*K1_in(-iz,scaled);
        } else {
            Cplx Kv=NaN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I1_in(iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K1_in(iz,false)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=-s*M_1_PI*Kv+1i*Iv*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*ret;
    }
    /* Hankel functions */
    Cplx HankelH1(Real v,const Cplx &z,bool scaled) {
        if (v==0.0) {
#ifdef USE_STD_BESSEL
            if (!scaled && zero(imag(z)) && real(z)>0)
                return Cplx(j0(real(z)),y0(real(z)));
#endif
            return H_v0(z,1,scaled);
        }
        if (v==1.0) {
#ifdef USE_STD_BESSEL
            if (!scaled && zero(imag(z)) && real(z)>0)
                return Cplx(j1(real(z)),y1(real(z)));
#endif
            return H_v1(z,1,scaled);
        }
        return H(v,z,1,scaled);
    }
    Cplx HankelH2(Real v,const Cplx &z,bool scaled) {
        if (v==0.0) {
#ifdef USE_STD_BESSEL
            if (!scaled && zero(imag(z)) && real(z)>0)
                return Cplx(j0(real(z)),-y0(real(z)));
#endif
            return H_v0(z,2,scaled);
        }
        if (v==1.0) {
#ifdef USE_STD_BESSEL
            if (!scaled && zero(imag(z)) && real(z)>0)
                return Cplx(j1(real(z)),-y1(real(z)));
#endif
            return H_v1(z,2,scaled);
        }
        return H(v,z,2,scaled);
    }

    /* n-th derivative of Bessel function f_v(z) */
    Cplx bessel_derive(Real v,const Cplx &z,int n,Cplx (*f)(Real,const Cplx&,bool),bool alt) {
        Cplx ret=0.0,t;
        int C=1,k=0;
        for (;k<=n;++k) {
            try { t=f(v-n+2*k,z,false); }
            catch (const underflow_error &e) { t=0.0; }
            ret+=(alt&&k%2?-1.0:1.0)*C*t;
            C=(C*(n-k))/(k+1);
        }
        if (zero(ret))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        ret*=pow(2.0,-n);
        return ret;
    }
    Cplx BesselIp(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&BesselI,false);
    }
    Cplx BesselJp(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&BesselJ,true);
    }
    Cplx BesselKp(Real v,const Cplx &z,int n) {
        return (n%2?-1.0:1.0)*bessel_derive(v,z,n,&BesselK,false);
    }
    Cplx BesselYp(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&BesselY,true);
    }
    Cplx HankelH1p(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&HankelH1,true);
    }
    Cplx HankelH2p(Real v,const Cplx& z,int n) {
        return bessel_derive(v,z,n,&HankelH2,true);
    }

    /* Compute f and g (resp. f' and g' if p=true) for Airy power series.
     * MODE is 1 for f,g, 2 for f',g', and 3 for both f,g and f',g'. */
    void airy_series(const Cplx &z,int mode,Cplx &f,Cplx &g,Cplx &fp,Cplx &gp) {
        Cplx z3=pow(z,3),zp=1.0;
        Real z3a=1.0/abs(z3),tol=eps/(mode>1?1.07:1.05);
        f=g=fp=gp=1.0;
        const Real *fc=&fg_coef[0],*fpc=&fg_coef[14],*gc=&fg_coef[7],*gpc=&fg_coef[21];
        bool np=mode%2,p=mode>1;
        for (int j=0;j<7&&(*fc>=tol||*gc>=tol);++j,++fc,++gc,++fpc,++gpc) {
            tol*=z3a,zp*=z3;
            if (np) f+=*fc*zp,g+=*gc*zp;
            if (p) fp+=*fpc*zp,gp+=*gpc*zp;
        }
    }
    /* Airy functions and their first derivatives */
    Cplx AiryAi(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,1,f,g,fp,gp);
            return (scaled?exp(f23*pow(z,f32)):1.0)*(airy_C1*f-airy_C2*z*g);
        }
        Real a=arg(z);
        Cplx si=sign1(a)*1i,sz=sqrt(z),w=f23*sz*z,Kv=NaN,Iv;
        if (abs(a)<=M_PI*f23)
            return M_1_PI*sqrt_1_3*sz*K_in(f13,w,scaled);
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f13,-w,scaled,&Kv)*(scaled?exp(1i*imag(w)):1.0);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f13,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return sqrt_1_3*sz*(M_1_PI*Kv*exp((scaled?w:0.0)-si*M_PI*f13)-si*Iv);
    }
    Cplx AiryAip(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,2,f,g,fp,gp);
            return (scaled?exp(f23*pow(z,f32)):1.0)*(z*z*airy_C1*fp*0.5-airy_C2*gp);
        }
        Real a=arg(z),b=M_PI*f23;
        Cplx is=sign1(a)*1i,w=f23*pow(z,1.5),Kv=NaN,Iv;
        if (abs(a)<=b)
            return -M_1_PI*z*sqrt_1_3*K_in(f23,w,scaled);
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f23,-w,scaled,&Kv)*(scaled?exp(1i*imag(w)):1.0);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f23,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return z*sqrt_1_3*(is*Iv-M_1_PI*Kv*exp((scaled?w:0.0)-is*b));
    }
    Cplx AiryBi(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,1,f,g,fp,gp);
            return (scaled?exp(-f23*abs(real(pow(z,f32)))):1.0)
                *(airy_C1*f+airy_C2*z*g)/sqrt_1_3;
        }
        Real a=arg(z),s=sign1(a),b=M_PI*f23;
        Cplx is=s*1i,sz=sqrt(z),w=f23*z*sz,Kv=NaN,Iv,h1,h2;
        if (abs(a)<=b) {
            int k=int(round((s+1.0)*0.5));
            Real t=sign1(real(w));
#ifdef CBESSEL_EXCEPT
            try {
#endif
                h1=H(f13,-is*w,2-k,scaled && t>0.0)
                    *exp((scaled?(t>0.0?1i*imag(w):-abs(real(w))):0.0)+M_PI*is*f16);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h1=0.0; }
            try {
#endif
                h2=H(f13,-is*w,1+k,scaled && t<0.0)
                    *exp((scaled?(t<0.0?-1i*imag(w):-abs(real(w))):0.0)-M_PI*is*f16);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h2=0.0; }
#endif
            return sqrt_1_3*sz*(h1+0.5*h2);
        }
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f13,-w,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f13,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return sz*(Iv*sqrt_1_3+M_1_PI*exp((scaled?real(w):0.0)-is*M_PI*f13)*Kv);
    }
    Cplx AiryBip(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,2,f,g,fp,gp);
            return (scaled?exp(-f23*abs(real(pow(z,f32)))):1.0)
                *(z*z*airy_C1*fp*0.5+airy_C2*gp)/sqrt_1_3;
        }
        Real a=arg(z),s=sign1(a),b=M_PI*f23;
        Cplx is=s*1i,w=f23*pow(z,1.5),Kv=NaN,Iv,h1,h2;
        if (abs(a)<=b) {
            int k=int(round((s+1.0)*0.5));
            Real t=sign1(real(w));
#ifdef CBESSEL_EXCEPT
            try {
#endif
                h1=H(f23,-is*w,2-k,scaled && t>0.0)
                    *exp((scaled?(t>0.0?1i*imag(w):-abs(real(w))):0.0)+is*M_PI*f13);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h1=0.0; }
            try {
#endif
                h2=H(f23,-is*w,1+k,scaled && t<0.0)
                    *exp((scaled?(t<0.0?-1i*imag(w):-abs(real(w))):0.0)-is*M_PI*f13);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h2=0.0; }
#endif
            return z*sqrt_1_3*(h1-0.5*h2);
        }
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f23,-w,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f23,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return z*(M_1_PI*exp((scaled?real(w):0.0)-is*M_PI*f23)*Kv-Iv*sqrt_1_3);
    }
    /* Compute both Ai and Aip for Olver expansions.
     * Return 0 if AI and AIP are both normal, 1 if
     * one of them is infinite and 2 if both are zero. */
    int airy_olver(Real v,const Cplx &xi,Real s,Cplx &ai,Cplx &aip,bool &corr,bool rot,bool scaled) {
        Real b=M_PI*f23,t=sign1(imag(xi));
        Cplx alpha=s*t>=0.0?pow(v/f23*xi,f23):pow(v/f23*abs(xi),f23)*exp((arg(xi)-t*2.0*M_PI)*f23*1i);
        Cplx beta=alpha*(rot?exp(-s*b*1i):1.0);
        corr=false;
        if (abs(alpha)<=1) {
            Cplx f,g,fp,gp;
            airy_series(beta,3,f,g,fp,gp);
            ai=airy_C1*f-airy_C2*beta*g;
            aip=beta*beta*airy_C1*fp*0.5-airy_C2*gp;
        } else
#ifdef CBESSEL_EXCEPT
            try
#endif
        {
            corr=true;
            Real a=arg(beta),sa=sign1(a);
            Cplx is=sa*1i,sz=sqrt(beta*f13),w=(rot?-v:v)*xi;
            if (abs(a)<=b) {
#ifdef CBESSEL_EXCEPT
                try {
#endif
                    ai=M_1_PI*sz*BesselK(f13,w,scaled);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { ai=0.0; }
                try {
#endif
                    aip=-M_1_PI*beta*sqrt_1_3*BesselK(f23,w,scaled);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { aip=0.0; }
#endif
            } else {
                Cplx sf=scaled?exp(1i*imag(w)):1.0;
#ifdef CBESSEL_EXCEPT
                try {
#endif
                    ai=sz*(M_1_PI*BesselK(f13,-w)*exp((scaled?w:0.0)-is*M_PI*f13)-is*BesselI(f13,-w,scaled)*sf);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { ai=0.0; }
                try {
#endif
                    aip=beta*sqrt_1_3*(is*BesselI(f23,-w,scaled)*sf-M_1_PI*BesselK(f23,-w)*exp((scaled?w:0.0)-is*b));
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { aip=0.0; }
#endif
            }
#ifdef CBESSEL_EXCEPT
        } catch (const overflow_error &e) {
            return 1;
#endif
        }
#ifdef CBESSEL_EXCEPT
        if (zero(ai) && zero(aip))
            return 2;
#endif
        return 0;
    }

    /**
     * Vectorized variants; fast J, Y
     * and Hankel of integral order
     */

#ifdef COMPUTE_BESSEL_STATS
    static Real bessel_accuracy = 0.;
    static Real trig_accuracy = 0.;
    static unsigned long bessel_eval_count = 0;
    static unsigned long bessel_eval_count_limit = 0;
    static unsigned long bessel_eval_count_small = 0;
    static unsigned long bessel_eval_count_normal = 0;
    static unsigned long trig_eval_count = 0;
#endif
    static const Real
    invsqrtpi= 5.64189583547756279280e-01,
    tpi    =   6.36619772367581382433e-01,
    twopi  =   6.283185307179586,
#ifdef SIN_REDUCE_TO_PI_2
    SC[9]  = { 1.5707963267948903687949521673154,
              -0.64596409750608752345975628737805,
               0.079692626244476767418872925870296,
              -0.0046817541259287396053304463458301,
               0.00016044115560048214207249631415992,
              -0.0000035987905722704992281543683554946,
               0.000000056866838534603819775775526363909,
              -0.00000000063806054563344757839062149726345,
              -0.0000000000011580046200244057807738288899691 },
#else
    SC[12] = { 3.1415926535897976217383768050226,
              -5.1677127800502388476848351802381,
               2.5501640398831877485061704171373,
              -0.59926452938501642037615228973718,
               0.08214588701972088888770292372269,
              -0.0073704325594585246683492700917021,
               0.00046630692306576588187803332069338,
              -0.000021922252643443037564615173772605,
               0.00000080274628123315158747800507557487,
              -0.000000028123589703067724519562415872539,
               0.0000000025632432264240220050026142527478,
              -0.0000000003543494137274681386245328798437 },
#endif
    A0[5]  = { 0.12500000000000000000000000000000,
              -0.65104166666666666666666666666666e-1,
               0.20957031250000000000000000000000,
              -1.6380658830915178571428571428571,
               0.23475127749972873263888888888889e2 },
    B0[5]  = { 0.79788456080286535587989211986876,
              -0.49867785050179084742493257491798e-1,
               0.82593518989359109104754457720790e-1,
              -0.43312898460575466767552249231645,
               4.6665870874397062985728623123969 },
    A1[5] =  {-0.37500000000000000000000000000000,
               0.16406250000000000000000000000000,
              -0.37089843750000000000000000000000,
               2.3693978445870535714285714285714,
              -0.30624011993408203125000000000000e2 },
    B1[5] =  { 0.79788456080286535587989211986876,
               0.14960335515053725422747977247539,
              -0.15427845999899154342208851536525,
               0.64253472260943637118403910092459,
              -6.1755897937362661626303604625764 },
    R0[6]  = { 0, 0,
               1.56249999999999947958e-02,-1.89979294238854721751e-04,1.82954049532700665670e-06,-4.61832688532103189199e-09 },
    S0[5]  = { 0,
               1.56191029464890010492e-02, 1.16926784663337450260e-04, 5.13546550207318111446e-07, 1.16614003333790000205e-09 },
    u0[7]  = {-7.38042951086872317523e-02, 1.76666452509181115538e-01,-1.38185671945596898896e-02, 3.47453432093683650238e-04,
              -3.81407053724364161125e-06, 1.95590137035022920206e-08,-3.98205194132103398453e-11 },
    v0[5]  = { 0,
               1.27304834834123699328e-02, 7.60068627350353253702e-05, 2.59150851840457805467e-07, 4.41110311332675467403e-10 },
    U0[5]  = {-1.96057090646238940668e-01, 5.04438716639811282616e-02,-1.91256895875763547298e-03,
               2.35252600561610495928e-05,-9.19099158039878874504e-08 },
    V0[5]  = { 1.99167318236649903973e-02, 2.02552581025135171496e-04, 1.35608801097516229404e-06,
               6.22741452364621501295e-09, 1.66559246207992079114e-11 },
    r0[4]  = {-6.25000000000000000000e-02, 1.40705666955189706048e-03,-1.59955631084035597520e-05, 4.96727999609584448412e-08 },
    s0[6]  = { 0,
               1.91537599538363460805e-02, 1.85946785588630915560e-04, 1.17718464042623683263e-06,
               5.04636257076217042715e-09, 1.23542274426137913908e-11 },
    pR8[6] = { 0.00000000000000000000e+00,-7.03124999999900357484e-02,-8.08167041275349795626e+00,
              -2.57063105679704847262e+02,-2.48521641009428822144e+03,-5.25304380490729545272e+03 },
    pS8[5] = { 1.16534364619668181717e+02, 3.83374475364121826715e+03, 4.05978572648472545552e+04,
               1.16752972564375915681e+05, 4.76277284146730962675e+04 },
    pR5[6] = {-1.14125464691894502584e-11,-7.03124940873599280078e-02,-4.15961064470587782438e+00,
              -6.76747652265167261021e+01,-3.31231299649172967747e+02,-3.46433388365604912451e+02 },
    pS5[5] = { 6.07539382692300335975e+01, 1.05125230595704579173e+03, 5.97897094333855784498e+03,
               9.62544514357774460223e+03, 2.40605815922939109441e+03 },
    pR3[6] = {-2.54704601771951915620e-09,-7.03119616381481654654e-02,-2.40903221549529611423e+00,
              -2.19659774734883086467e+01,-5.80791704701737572236e+01,-3.14479470594888503854e+01 },
    pS3[5] = { 3.58560338055209726349e+01, 3.61513983050303863820e+02, 1.19360783792111533330e+03,
               1.12799679856907414432e+03, 1.73580930813335754692e+02 },
    pR2[6] = {-8.87534333032526411254e-08,-7.03030995483624743247e-02,-1.45073846780952986357e+00,
              -7.63569613823527770791e+00,-1.11931668860356747786e+01,-3.23364579351335335033e+00 },
    pS2[5] = { 2.22202997532088808441e+01, 1.36206794218215208048e+02, 2.70470278658083486789e+02,
               1.53875394208320329881e+02, 1.46576176948256193810e+01 },
    qR8[6] = { 0.00000000000000000000e+00, 7.32421874999935051953e-02, 1.17682064682252693899e+01,
               5.57673380256401856059e+02, 8.85919720756468632317e+03, 3.70146267776887834771e+04 },
    qS8[6] = { 1.63776026895689824414e+02, 8.09834494656449805916e+03, 1.42538291419120476348e+05,
               8.03309257119514397345e+05, 8.40501579819060512818e+05, -3.43899293537866615225e+05 },
    qR5[6] = { 1.84085963594515531381e-11, 7.32421766612684765896e-02, 5.83563508962056953777e+00,
               1.35111577286449829671e+02, 1.02724376596164097464e+03, 1.98997785864605384631e+03 },
    qS5[6] = { 8.27766102236537761883e+01, 2.07781416421392987104e+03, 1.88472887785718085070e+04,
               5.67511122894947329769e+04, 3.59767538425114471465e+04,-5.35434275601944773371e+03 },
    qR3[6] = { 4.37741014089738620906e-09, 7.32411180042911447163e-02, 3.34423137516170720929e+00,
               4.26218440745412650017e+01, 1.70808091340565596283e+02, 1.66733948696651168575e+02 },
    qS3[6] = { 4.87588729724587182091e+01, 7.09689221056606015736e+02, 3.70414822620111362994e+03,
               6.46042516752568917582e+03, 2.51633368920368957333e+03,-1.49247451836156386662e+02 },
    qR2[6] = { 1.50444444886983272379e-07, 7.32234265963079278272e-02, 1.99819174093815998816e+00,
               1.44956029347885735348e+01, 3.16662317504781540833e+01, 1.62527075710929267416e+01 },
    qS2[6] = { 3.03655848355219184498e+01, 2.69348118608049844624e+02, 8.44783757595320139444e+02,
               8.82935845112488550512e+02, 2.12666388511798828631e+02,-5.31095493882666946917e+00 },
    pr8[6] = { 0.00000000000000000000e+00, 1.17187499999988647970e-01, 1.32394806593073575129e+01,
               4.12051854307378562225e+02, 3.87474538913960532227e+03, 7.91447954031891731574e+03 },
    ps8[5] = { 1.14207370375678408436e+02, 3.65093083420853463394e+03, 3.69562060269033463555e+04,
               9.76027935934950801311e+04, 3.08042720627888811578e+04 },
    pr5[6] = { 1.31990519556243522749e-11, 1.17187493190614097638e-01, 6.80275127868432871736e+00,
               1.08308182990189109773e+02, 5.17636139533199752805e+02, 5.28715201363337541807e+02 },
    ps5[5] = { 5.92805987221131331921e+01, 9.91401418733614377743e+02, 5.35326695291487976647e+03,
               7.84469031749551231769e+03, 1.50404688810361062679e+03 },
    pr3[6] = { 3.02503916137373618024e-09, 1.17186865567253592491e-01, 3.93297750033315640650e+00,
               3.51194035591636932736e+01, 9.10550110750781271918e+01, 4.85590685197364919645e+01 },
    ps3[5] = { 3.47913095001251519989e+01, 3.36762458747825746741e+02, 1.04687139975775130551e+03,
               8.90811346398256432622e+02, 1.03787932439639277504e+02 },
    pr2[6] = { 1.07710830106873743082e-07, 1.17176219462683348094e-01, 2.36851496667608785174e+00,
               1.22426109148261232917e+01, 1.76939711271687727390e+01, 5.07352312588818499250e+00 },
    ps2[5] = { 2.14364859363821409488e+01, 1.25290227168402751090e+02, 2.32276469057162813669e+02,
               1.17679373287147100768e+02, 8.36463893371618283368e+00 },
    qr8[6] = { 0.00000000000000000000e+00,-1.02539062499992714161e-01,-1.62717534544589987888e+01,
              -7.59601722513950107896e+02,-1.18498066702429587167e+04,-4.84385124285750353010e+04 },
    qs8[6] = { 1.61395369700722909556e+02, 7.82538599923348465381e+03, 1.33875336287249578163e+05,
               7.19657723683240939863e+05, 6.66601232617776375264e+05,-2.94490264303834643215e+05 },
    qr5[6] = {-2.08979931141764104297e-11,-1.02539050241375426231e-01,-8.05644828123936029840e+00,
              -1.83669607474888380239e+02,-1.37319376065508163265e+03,-2.61244440453215656817e+03 },
    qs5[6] = { 8.12765501384335777857e+01, 1.99179873460485964642e+03, 1.74684851924908907677e+04,
               4.98514270910352279316e+04, 2.79480751638918118260e+04,-4.71918354795128470869e+03 },
    qr3[6] = {-5.07831226461766561369e-09,-1.02537829820837089745e-01,-4.61011581139473403113e+00,
              -5.78472216562783643212e+01,-2.28244540737631695038e+02,-2.19210128478909325622e+02 },
    qs3[6] = { 4.76651550323729509273e+01, 6.73865112676699709482e+02, 3.38015286679526343505e+03,
               5.54772909720722782367e+03, 1.90311919338810798763e+03,-1.35201191444307340817e+02 },
    qr2[6] = {-1.78381727510958865572e-07,-1.02517042607985553460e-01,-2.75220568278187460720e+00,
              -1.96636162643703720221e+01,-4.23253133372830490089e+01,-2.13719211703704061733e+01 },
    qs2[6] = { 2.95333629060523854548e+01, 2.52981549982190529136e+02, 7.57502834868645436472e+02,
               7.39393205320467245656e+02, 1.55949003336666123687e+02,-4.95949898822628210127e+00 };

    Hankel1Real01::Hankel1Real01(size_t m,size_t n) {
        initialize(m,n);
    }

    void Hankel1Real01::initialize(size_t m,size_t n) {
        _m=m; _n=n;
        n_elem=m*n;
        for (size_t i=9;i<13;++i)
            ws[i].resize(m,n);
        m_0.setZero(_m,_n);
        ind_limit.reserve(n_elem);
        ind_small.reserve(n_elem);
        ind_normal.reserve(n_elem);
        ind_large.reserve(n_elem);
        x_limit.resize(n_elem,1);
        x_small.resize(n_elem,1);
        x_normal.resize(n_elem,1);
        x_large.resize(n_elem,1);
        j0_limit.resize(n_elem,1);
        j0_small.resize(n_elem,1);
        j1_small.resize(n_elem,1);
        y0_small.resize(n_elem,1);
        y1_small.resize(n_elem,1);
    }

    void Hankel1Real01::nsin(const RealArray &x,RealArray &xx,RealArray &res) {
#ifdef SIN_REDUCE_TO_PI_2
        unsigned prec=8;
#else
        unsigned prec=11;
#endif
        res.setConstant(SC[prec]);
        for (unsigned i=prec;i-->0;)
            res=res*xx+SC[i];
        res*=x;
#ifdef COMPUTE_BESSEL_STATS
        trig_eval_count+=x.rows()*x.cols();
        trig_accuracy+=((res-(M_PI/2*x).sin()).cwiseAbs() / res.cwiseAbs()).sum();
#endif
    }

    void Hankel1Real01::sin_cos(const RealArray& x,RealArray& xt,RealArray& xx,RealArray& s,RealArray& c) {
        xt=x-(x/twopi).floor()*twopi;
        xt=M_1_PI*(xt>M_PI).select(xt-twopi,xt);
#ifdef SIN_REDUCE_TO_PI_2
        tmsk1=xt>.5;
        tmsk2=xt<-.5;
        xt=tmsk1.select(1.-xt,tmsk2.select(-1.-xt,xt));
        xt+=xt;
#endif
        xx=xt*xt;
        nsin(xt,xx,s); // compute s=sin(x)
#ifdef SIN_REDUCE_TO_PI_2
        xt=1.-xt.cwiseAbs();
        xx+=xt+xt-1.;
        nsin(xt,xx,c); // compute c=cos(x)
        c=(tmsk1 || tmsk2).select(-c,c);
#else
        xt=.5-xt.cwiseAbs();
        xx+=xt-.25;
        nsin(xt,xx,c); // compute c=cos(x)
#endif
    }

    void Hankel1Real01::compute_limit(const RealArray &x,RealArray &j_0,RealArray &j_1,RealArray &y_0,RealArray &y_1) {
        j_0.setOnes();
        j_1=.5*x;
        y_0=M_2_PI*(j_1.log()-D[9]);
        y_1=-M_2_PI*x.inverse();
    }

    void Hankel1Real01::compute_small(const RealArray& x,RealArray& j_0,RealArray& j_1,RealArray& y_0,RealArray& y_1) {
        Eigen::Index max_i,max_j;
        x.maxCoeff(&max_i,&max_j);
        auto &x2_4=ws[0],&t=ws[1];
        x2_4=x.square()*0.25;
        t.setOnes(x.rows(),x.cols());
        j_0.setOnes();
        j_1.setOnes();
        y_0.setZero();
        y_1.setZero();
        Real Hk=0,k=1.0,maxiter=CBESSEL_MAXITER;
        do {
            t*=-x2_4/(k*k);
            Hk+=1.0/k;
            j_0+=t;
            y_0-=Hk*t;
            k+=1.0;
            j_1+=t/k;
            y_1-=(Hk/k)*t;
        } while (Hk*abs(t(max_i,max_j))>eps && k<=maxiter);
        j_1*=x*0.5;
        ws[0]=(x*0.5).log()-D[9];
        y_0+=ws[0]*j_0;
        y_0*=M_2_PI;
        y_1*=x;
        y_1+=2.0*(ws[0]*j_1+(j_0-2.0)/x);
        y_1*=M_1_PI;
    }

    void Hankel1Real01::compute_normal(const RealArray &x,RealArray &j_0,RealArray &j_1,RealArray &y_0,RealArray &y_1) {
        auto &invx=ws[0],&invxx=ws[1],&r=ws[2],&s=ws[3],&c=ws[4],&u1=ws[5],&v1=ws[6],&u2=ws[7],&v2=ws[8];
        invx=1./x;
        invxx=invx*invx;
        r=pR8[0]+invxx*(pR8[1]+invxx*(pR8[2]+invxx*(pR8[3]+invxx*(pR8[4]+invxx*pR8[5]))));
        s=1.+invxx*(pS8[0]+invxx*(pS8[1]+invxx*(pS8[2]+invxx*(pS8[3]+invxx*pS8[4]))));
        u1=1.+r/s;
        r=qR8[0]+invxx*(qR8[1]+invxx*(qR8[2]+invxx*(qR8[3]+invxx*(qR8[4]+invxx*qR8[5]))));
        s=1.+invxx*(qS8[0]+invxx*(qS8[1]+invxx*(qS8[2]+invxx*(qS8[3]+invxx*(qS8[4]+invxx*qS8[5])))));
        v1=(-.125+r/s)*invx;
        r=pr8[0]+invxx*(pr8[1]+invxx*(pr8[2]+invxx*(pr8[3]+invxx*(pr8[4]+invxx*pr8[5]))));
        s=1.+invxx*(ps8[0]+invxx*(ps8[1]+invxx*(ps8[2]+invxx*(ps8[3]+invxx*ps8[4]))));
        u2=1.+r/s;
        r=qr8[0]+invxx*(qr8[1]+invxx*(qr8[2]+invxx*(qr8[3]+invxx*(qr8[4]+invxx*qr8[5]))));
        s=1.+invxx*(qs8[0]+invxx*(qs8[1]+invxx*(qs8[2]+invxx*(qs8[3]+invxx*(qs8[4]+invxx*qs8[5])))));
        v2=(.375+r/s)*invx;
#if 0
        s=x.sin();
        r=x.cos();
#else
        auto &xx=ws[1];
        sin_cos(x,c,xx,s,r);
#endif
        c=s+r;
        s-=r;
#if 0 // numerical improvement
        r=-(x+x).cos();
        auto mask=s*c<0.;
        c=mask.select(c,r/s);
        s=mask.select(r/c,s);
#endif
        r=invsqrtpi*invx.sqrt();
        c*=r;
        s*=r;
        j_0=u1*c-v1*s;
        y_0=u1*s+v1*c;
        j_1=u2*s+v2*c;
        y_1=v2*s-u2*c;
    }

    void Hankel1Real01::compute_large(const RealArray &x,RealArray &j_0,RealArray &j_1,RealArray &y_0,RealArray &y_1) {
        j_0=j_1=y_0=y_1=(M_2_PI/x).cwiseSqrt();
        auto &xt=ws[0],&xx=ws[1],&s=ws[2],&c=ws[3];
        s.resize(x.rows(),x.cols());
        c.resize(x.rows(),x.cols());
        sin_cos(x-M_PI_4,xt,xx,s,c);
        j_0*=c,y_0*=s;
        sin_cos(x-3*M_PI_4,xt,xx,s,c);
        j_1*=c,y_1*=s;
    }

    void Hankel1Real01::jy_01(const RealArray &x,RealArray &j_0,RealArray &y_0,RealArray &j_1,RealArray &y_1) {
#if 0
        if (x.minCoeff()>=50.) { // Paper: 10.1109/ARITH.2009.32
            auto &a0=ws[0],&a1=ws[1],&b0=ws[2],&b1=ws[3],&invx=ws[4],&invxx=ws[5],&invsqrtx=ws[6],&s=ws[7],&c=ws[8];
            unsigned i;
            invx=1./x;
            invxx=invx*invx;
            invsqrtx=invx.sqrt();
            a0.setConstant(A0[4]);
            for (i=4;i-->0;) a0=a0*invxx+A0[i];
            a0*=invx;
            b0.setConstant(B0[4]);
            for (i=4;i-->0;) b0=b0*invxx+B0[i];
            a1.setConstant(A1[4]);
            for (i=4;i-->0;) a1=a1*invxx+A1[i];
            a1*=invx;
            b1.setConstant(B1[4]);
            for (i=4;i-->0;) b1=b1*invxx+B1[i];
            auto &xx=ws[4],&xt=ws[5];
            sin_cos(x-M_PI_4-a0,xt,xx,s,c);
            j_0=b0*c;
            y_0=b0*s;
            sin_cos(x-(3.*M_PI_4)-a1,xt,xx,s,c);
            j_1=b1*c;
            y_1=b1*s;
            return;
        }
#endif
        size_t i,j,k;
        n_limit=n_small=n_normal=n_large=n_zero=0;
        ind_limit.clear();
        ind_small.clear();
        ind_normal.clear();
        ind_large.clear();
        x_limit.conservativeResize(n_elem,Eigen::NoChange);
        x_small.conservativeResize(n_elem,Eigen::NoChange);
        x_normal.conservativeResize(n_elem,Eigen::NoChange);
        x_large.conservativeResize(n_elem,Eigen::NoChange);
        for (j=0;j<_n;++j) {
            for (i=0;i<_m;++i) {
                Real xij=x(i,j);
                if (xij<=0.0) {
                    n_zero++;
                } else if (xij<LIMITING_FORMS_THRESHOLD) { // limit
                    ind_limit.push_back({i,j});
                    x_limit(n_limit++,0)=xij;
                } else if (xij<8.) { // small (x<8)
                    ind_small.push_back({i,j});
                    x_small(n_small++,0)=xij;
                } else if (xij>1e6) { // large (x>1e6)
                    ind_large.push_back({i,j});
                    x_large(n_large++,0)=xij;
                } else { // normal (x>=8)
                    ind_normal.push_back({i,j});
                    x_normal(n_normal++,0)=xij;
                }
            }
        }
        if (n_limit+n_zero==n_elem) {
            compute_limit(x,j_0,j_1,y_0,y_1);
        } else if (n_small+n_zero==n_elem) {
            compute_small(x,j_0,j_1,y_0,y_1);
        } else if (n_large+n_zero==n_elem) {
            compute_large(x,j_0,j_1,y_0,y_1);
        } else if (n_normal+n_zero==n_elem) {
            compute_normal(x,j_0,j_1,y_0,y_1);
        } else {
            vector<pair<size_t,size_t> >::const_iterator it;
            if (n_limit>0) {
                x_limit.conservativeResize(n_limit,Eigen::NoChange);
                j0_limit.conservativeResize(n_limit,Eigen::NoChange);
                compute_limit(x_limit,j0_limit,j1_limit,y0_limit,y1_limit);
                for (k=0,it=ind_limit.begin();k<n_limit;++k,++it) {
                    i=it->first,j=it->second;
                    j_0(i,j)=j0_limit(k,0);
                    j_1(i,j)=j1_limit(k,0);
                    y_0(i,j)=y0_limit(k,0);
                    y_1(i,j)=y1_limit(k,0);
                }
            }
            if (n_small>0) {
                x_small.conservativeResize(n_small,Eigen::NoChange);
                j0_small.conservativeResize(n_small,Eigen::NoChange);
                j1_small.conservativeResize(n_small,Eigen::NoChange);
                y0_small.conservativeResize(n_small,Eigen::NoChange);
                y1_small.conservativeResize(n_small,Eigen::NoChange);
                compute_small(x_small,j0_small,j1_small,y0_small,y1_small);
                for (k=0,it=ind_small.begin();k<n_small;++k,++it) {
                    i=it->first,j=it->second;
                    j_0(i,j)=j0_small(k,0);
                    j_1(i,j)=j1_small(k,0);
                    y_0(i,j)=y0_small(k,0);
                    y_1(i,j)=y1_small(k,0);
                }
            }
            if (n_large>0) {
                x_large.conservativeResize(n_large,Eigen::NoChange);
                compute_large(x_large,j0_large,j1_large,y0_large,y1_large);
                for (k=0,it=ind_large.begin();k<n_large;++k,++it) {
                    i=it->first,j=it->second;
                    j_0(i,j)=j0_large(k,0);
                    j_1(i,j)=j1_large(k,0);
                    y_0(i,j)=y0_large(k,0);
                    y_1(i,j)=y1_large(k,0);
                }
            }
            if (n_normal>0) {
                x_normal.conservativeResize(n_normal,Eigen::NoChange);
                compute_normal(x_normal,j0_normal,j1_normal,y0_normal,y1_normal);
                for (k=0,it=ind_normal.begin();k<n_normal;++k,++it) {
                    i=it->first,j=it->second;
                    j_0(i,j)=j0_normal(k,0);
                    j_1(i,j)=j1_normal(k,0);
                    y_0(i,j)=y0_normal(k,0);
                    y_1(i,j)=y1_normal(k,0);
                }
            }
        }
        if (n_zero>0) {
            auto msk=(x<=0.);
            y_0=msk.select(m_0,y_0);
            y_1=msk.select(m_0,y_1);
        }
#ifdef COMPUTE_BESSEL_STATS
        RealArray err(_m,_n);
        err.setZero();
        for (j=0;j<_n;++j) for (i=0;i<_m;++i) {
            if (x(i,j)<=0)
                continue;
            Real J0=j0(x(i,j)),Y0=y0(x(i,j)),J1=j1(x(i,j)),Y1=y1(x(i,j));
            err(i,j)=abs(j_0(i,j)-J0)/(1.+abs(J0))+abs(j_1(i,j)-J1)/(1.+abs(J1))+
                     abs(y_0(i,j)-Y0)/(1.+abs(Y0))+abs(y_1(i,j)-Y1)/(1.+abs(Y1));
        }
        bessel_accuracy += err.sum();
        bessel_eval_count += (n_elem-n_zero) * 4;
        bessel_eval_count_limit += n_limit * 4;
        bessel_eval_count_small += n_small * 4;
        bessel_eval_count_normal += n_normal * 4;
#endif
    }
    void print_bessel_stats() {
#ifdef COMPUTE_BESSEL_STATS
        cout << "*** Bessel Statistic ***" << endl;
        cout << "Bessel evaluations: " << bessel_eval_count << endl;
        cout << "Limit / Small / Normal: " << (double(bessel_eval_count_limit) / double(bessel_eval_count)) * 100. << "%, "
                                                << (double(bessel_eval_count_small) / double(bessel_eval_count)) * 100. << "%, "
                                                << (double(bessel_eval_count_normal) / double(bessel_eval_count)) * 100. << "%" << endl;
        cout << "Mean accuracy: " << bessel_accuracy / double(bessel_eval_count) << endl;
        cout << "Trig accuracy: " << trig_accuracy / double(trig_eval_count) << endl;
#endif
        return;
    }

    void Hankel1Real01::h1_01(const RealArray& x,ComplexArray& h1_0,ComplexArray& h1_1) {
        assert(x.rows()==_m && x.cols()==_n);
        auto &j_0=ws[9],&y_0=ws[10],&j_1=ws[11],&y_1=ws[12];
        jy_01(x,j_0,y_0,j_1,y_1);
        h1_0=j_0+1i*y_0;
        h1_1=j_1+1i*y_1;
    }

    Real pzero(Real x) {
        const Real *p,*q;
        Real z,r,s;
        int ix=0x7fffffff&HI(x);
        if(ix>=0x40200000)     {p=pR8; q=pS8;}
        else if(ix>=0x40122E8B){p=pR5; q=pS5;}
        else if(ix>=0x4006DB6D){p=pR3; q=pS3;}
        else                   {p=pR2; q=pS2;}
        z=1./(x*x);
        r=p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
        s=1.+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
        return 1.+r/s;
    }
    Real qzero(Real x) {
        const Real *p,*q;
        Real s,r,z;
        int ix=0x7fffffff&HI(x);
        if(ix>=0x40200000)     {p=qR8; q=qS8;}
        else if(ix>=0x40122E8B){p=qR5; q=qS5;}
        else if(ix>=0x4006DB6D){p=qR3; q=qS3;}
        else                   {p=qR2; q=qS2;}
        z=1./(x*x);
        r=p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
        s=1.+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
        return (-.125+r/s)/x;
    }
    Real pone(Real x) {
        const Real *p,*q;
        Real z,r,s;
        int ix=0x7fffffff&HI(x);
        if(ix>=0x40200000)     {p=pr8; q=ps8;}
        else if(ix>=0x40122E8B){p=pr5; q=ps5;}
        else if(ix>=0x4006DB6D){p=pr3; q=ps3;}
        else                   {p=pr2; q=ps2;}
        z=1./(x*x);
        r=p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
        s=1.+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
        return 1.+r/s;
    }
    Real qone(Real x) {
        const Real *p,*q;
        Real  s,r,z;
        int ix=0x7fffffff&HI(x);
        if(ix>=0x40200000)     {p=qr8; q=qs8;}
        else if(ix>=0x40122E8B){p=qr5; q=qs5;}
        else if(ix>=0x4006DB6D){p=qr3; q=qs3;}
        else                   {p=qr2; q=qs2;}
        z=1./(x*x);
        r=p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
        s=1.+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
        return (.375+r/s)/x;
    }

    void JY_01(Real x,Real &j_0,Real &y_0,Real &j_1,Real &y_1) {
        assert(x>=0);
        if (x<=0) {
            j_0=1.0;
            j_1=y_0=y_1=0.0;
        } else if (x<LIMITING_FORMS_THRESHOLD) { // use limiting forms
            j_0=1.0;
            j_1=.5*x;
            y_0=M_2_PI*(log(x)-D[9]);
            y_1=-M_2_PI/x;
        } else {
            Real z,s,c,ss,cc,r,u,v,logx;
            int ix=HI(x)&0x7fffffff;
            if(ix>=0x7ff00000) {
                j_0=1./(x*x);
                y_0=y_1=1./(x+x*x);
                j_1=1./x;
            } else if(ix>=0x40000000) { /* |x| >= 2.0 */
                s=sin(x);
                c=cos(x);
                ss=s-c;
                cc=s+c;
#if 0 // numerical improvement
                if(ix<0x7fe00000) { /* make sure x+x not overflow */
                    z=-cos(x+x);
                    if ((s*c)<0.) cc=z/ss;
                    else ss=z/cc;
                }
#endif
                r=invsqrtpi/sqrt(x);
                ss*=r; cc*=r;
                if(ix>0x48000000) {
                    j_0=cc;
                    y_0=j_1=ss;
                    y_1=-cc;
                } else {
                    u=pzero(x); v=qzero(x);
                    j_0=u*cc-v*ss;
                    y_0=u*ss+v*cc;
                    u=pone(x); v=qone(x);
                    j_1=u*ss+v*cc;
                    y_1=v*ss-u*cc;
                }
            } else {
                logx=log(x);
                z=x*x;
                r=z*(R0[2]+z*(R0[3]+z*(R0[4]+z*R0[5])));
                s=1.+z*(S0[1]+z*(S0[2]+z*(S0[3]+z*S0[4])));
                if(ix<0x3FF00000) { /* |x| < 1.00 */
                    j_0=1.+z*(-0.25+(r/s));
                } else {
                    u=0.5*x;
                    j_0=((1.+u)*(1.-u)+z*(r/s));
                }
                u=u0[0]+z*(u0[1]+z*(u0[2]+z*(u0[3]+z*(u0[4]+z*(u0[5]+z*u0[6])))));
                v=1.+z*(v0[1]+z*(v0[2]+z*(v0[3]+z*v0[4])));
                y_0=u/v+tpi*j_0*logx;
                r=z*(r0[0]+z*(r0[1]+z*(r0[2]+z*r0[3])));
                s=1.+z*(s0[1]+z*(s0[2]+z*(s0[3]+z*(s0[4]+z*s0[5]))));
                r*=x;
                j_1=x*0.5+r/s;
                u=U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
                v=1.+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
                y_1=x*(u/v)+tpi*(j_1*logx-1./x);
            }
        }
    }

    void H1_01(Cplx z,Cplx& h0,Cplx& h1,bool realpos) {
        if (realpos || (z.imag()==0 && z.real()>0)) {
            /** optimize for real z */
            if (std::abs(z)>1e6) {
                /** use asymptotic formulas for large argument */
                Real r=std::sqrt(M_2_PI/z.real()),phi=z.real()-M_PI_4;
                h0=r*(std::cos(phi)+1i*std::sin(phi));
                phi-=M_PI_2;
                h1=r*(std::cos(phi)+1i*std::sin(phi));
            }
            Real j_0,y_0,j_1,y_1;
            JY_01(z.real(),j_0,y_0,j_1,y_1);
            h0=j_0+1i*y_0;
            h1=j_1+1i*y_1;
        } else {
            /** general algorithms for complex z */
            if (std::abs(z)>1e6) {
                /** use asymptotic formulas for large argument */
                Cplx r=std::sqrt(M_2_PI/z);
                h0=r*std::exp(1i*(z-M_PI_4));
                h1=r*std::exp(1i*(z-3*M_PI_4));
            }
            h0=HankelH1(0,z);
            h1=HankelH1(1,z);
        }
    }

}
